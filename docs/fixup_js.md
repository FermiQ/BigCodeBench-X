# fixup_js.py

## Overview

The `fixup_js.py` script is a Python utility designed to process JSONL files where each record contains a field with Markdown text (typically a "response" field from a language model). The script's primary function is to parse this Markdown content, extract all fenced code blocks (e.g., those enclosed in triple backticks), and then select the longest code block from these. This selected code block is assumed to be the primary program or code snippet of interest and is added as a new "program" field to each record. The modified records are then written to a new JSONL output file.

While named `fixup_js.py` (implying a focus on JavaScript), the Markdown parsing and code extraction logic itself is language-agnostic. It identifies any fenced code block regardless of the language specified (or not specified) in the Markdown. The selection of the "longest" block is a heuristic to pick the most substantial piece of code when multiple snippets are present.

## Key Components

### Helper Functions

-   **`_extract_code_blocks(acc: List[str], node: marko.block.BlockElement)`**:
    -   A recursive helper function used internally by `extract_fenced_code_blocks`.
    -   It traverses the abstract syntax tree (AST) of the parsed Markdown document (as generated by the `marko` library).
    -   When it encounters a `marko.block.FencedCode` node, it extracts the raw string content of that code block and appends it to the accumulator list `acc`.
    -   It continues to search for code blocks in nested `BlockElement` children.

-   **`extract_fenced_code_blocks(text: str) -> List[str]`**:
    -   **Purpose**: Parses a given Markdown string and extracts all fenced code blocks.
    -   **Input**: `text` - A string containing Markdown formatted text.
    -   **Processing**:
        1.  Parses the input `text` into a Markdown AST using `marko.parse()`.
        2.  Initializes an empty list to store found code blocks.
        3.  Calls the recursive helper `_extract_code_blocks` to populate this list.
    -   **Output**: A `List[str]`, where each string is the content of a fenced code block found in the input Markdown.

-   **`longest_code_block(texts: List[str]) -> str`**:
    -   **Purpose**: Selects the longest string from a list of strings.
    -   **Input**: `texts` - A list of strings (in this context, these are the code blocks extracted from a single "response" field).
    -   **Processing**: Uses `numpy.argmax` to find the index of the string with the maximum length in the list.
    -   **Output**: The string from the input list that has the greatest length.
    -   *Note*: If the input `texts` list is empty (i.e., no code blocks were found in the Markdown), this function will raise a `ValueError` due to `np.argmax([])`. Robust error handling for this case is not present in the current script version.

### Core Workflow Functions

-   **`main_with_args(src_file: str, out_file: str)`**:
    -   **Purpose**: Orchestrates the entire process of reading, processing, and writing data.
    -   **Processing**:
        1.  Reads the JSONL data from `src_file` into a pandas DataFrame using `pd.read_json(..., lines=True, orient="records")`.
        2.  Applies `extract_fenced_code_blocks` to each value in the "response" column of the DataFrame. This produces a pandas Series where each element is a list of code block strings.
        3.  (The script calculates `code_block_lens = code_blocks.apply(len)`, but this variable is not used further.)
        4.  Applies `longest_code_block` to the Series containing lists of code blocks. This selects the longest code block for each row, resulting in a new Series called `likely_code`.
        5.  Adds `likely_code` as a new column named "program" to the DataFrame. If a "program" column already exists, it will be overwritten.
        6.  Writes the modified DataFrame to `out_file` in JSONL format using `raw_df.to_json(..., orient="records", lines=True)`.

-   **`main()`**:
    -   **Purpose**: Parses command-line arguments.
    -   Uses `argparse.ArgumentParser` to define two positional string arguments: `src_file` (input file path) and `out_file` (output file path).
    -   Calls `main_with_args` with the parsed arguments.

## Important Variables/Constants

-   **Command-Line Arguments**:
    -   `src_file` (Positional, `str`): The path to the input JSONL file. Each line should be a JSON object with at least a "response" field containing Markdown text.
    -   `out_file` (Positional, `str`): The path to the output JSONL file where the processed data (including the new "program" field) will be saved.
-   **Key DataFrame Columns**:
    -   `"response"` (Input): The name of the column in the input JSONL data that contains the Markdown text to be parsed.
    -   `"program"` (Output): The name of the column added to the DataFrame (and output JSONL) that will store the longest fenced code block extracted from the "response" field.

## Usage Examples

**1. Prepare an Input JSONL File (e.g., `input_markdown.jsonl`):**
   ```json
   {"id": "A01", "response": "Here is some JavaScript code:\n```javascript\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\ngreet('World');\n```\nThis is how it works."}
   {"id": "A02", "response": "Two blocks here:\n```\n// Short block\nlet x = 10;\n```\nAnd a longer one:\n```python\n# Python code block\nfor i in range(5):\n  print(i)\n```"}
   {"id": "A03", "response": "This response has no fenced code blocks."}
   ```

**2. Run the Script:**
   ```bash
   python containers/js/fixup_js.py input_markdown.jsonl output_extracted_code.jsonl
   ```

**3. Inspect `output_extracted_code.jsonl`:**
   ```json
   {"id": "A01", "response": "Here is some JavaScript code:\n```javascript\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\ngreet('World');\n```\nThis is how it works.", "program": "function greet(name) {\n  console.log(`Hello, ${name}!`);\n}\ngreet('World');\n"}
   {"id": "A02", "response": "Two blocks here:\n```\n// Short block\nlet x = 10;\n```\nAnd a longer one:\n```python\n# Python code block\nfor i in range(5):\n  print(i)\n```", "program": "# Python code block\nfor i in range(5):\n  print(i)\n"}
   ```
   *Note on ID A03*: If "response" for ID A03 contains no fenced code blocks, `extract_fenced_code_blocks` will return an empty list. Passing an empty list to `longest_code_block` will cause a `ValueError` because `numpy.argmax` cannot operate on an empty sequence. The script would terminate unless this case is handled within `longest_code_block` (e.g., by returning `None` or an empty string if the input list is empty).

## Dependencies and Interactions

-   **Python Version**: Assumed to be Python 3.
-   **Standard Libraries**: `typing`, `argparse`.
-   **Third-Party Libraries**:
    -   `pandas`: Required for reading and manipulating the JSONL data in a DataFrame structure. Install via `pip install pandas`.
    -   `marko`: A Python Markdown parser used to convert Markdown text into an AST, enabling the extraction of fenced code blocks. Install via `pip install marko`.
    -   `numpy`: Used by the `longest_code_block` function (specifically `np.argmax`) to find the longest string. Install via `pip install numpy`.
-   **File System**:
    -   Reads the input JSONL file specified by `src_file`.
    -   Writes the processed data to the output JSONL file specified by `out_file`.
-   **Input Data Structure**: The script expects `src_file` to be a JSONL file (each line is a valid JSON object). Each JSON object must contain a field named "response" (or whatever field name the "response" column corresponds to after pandas reads it), and the value of this field should be a string containing Markdown text.
-   **Output Data Structure**: The output file will also be in JSONL format. Each JSON object will be a copy of the corresponding input object, augmented with a new field named "program". This "program" field will contain the string of the longest fenced code block found in the original "response" field. If no code blocks are found and the potential error in `longest_code_block` is not handled, the script may fail for that record or terminate.
```
